import requests
import os
import math
import pandas as pd
from PIL import Image
import io 
from dataclasses import dataclass

@dataclass
class Coord:
    """
    Represents a coordinate pair. 
    Attributes: 
        lat: Latitude coordinate as a float.
        lon: Longitude coordinate as a float.
    """
    lat: float
    lon: float
    
    def to_string(self):
        """Outputs coordinate pair as an f-string"""
        return f"{self.lat},{self.lon}"

@dataclass
class Pic: 
    heading: float = None
    number: int = 0
    stitch_count: int

@dataclass
class POI:
    fov: float = None
    errors = []
    num_pics = 1
    id = None
    lat: float
    lon: float
    key_word = "bus stop"
    coords = Coord(lat, lon)
    original_coords = Coord(lat, lon)
    pics = []
    pano_id: str = None
    pano_coords: Coord = None

    def get_entry(self):
        # Represents the row corresponding to this image in the log.
        entry = {'id': self.ID, 'num_imgs':self.num_imgs,
                 'updated_lat':self.coords.lat,'updated_lon':self.coords.lon, 
                 'heading': self.heading, 'fov':self.fov}
        
        # Only add Pano info if pull_pano_info was called
        if self.pano_id:
            entry.update({
                'pano_id': self.pano_id, 
                'pano_lat': self.pano_coords.lat, 'pano_lon':self.pano_coords.lon, 
            })

        # Only add updated coords if improve_coords was called
        if self.original_coords: 
            entry.update({
                'original_lat': self.original_coords.lat, 
                'original_lon':self.original_coords.lon,
            })
        return entry

@ dataclass
class Error: 
    context: str 
    msg: str 

class Session:
    # Parameters for all pics
    pic_height = 640
    pic_len = 640

    def __init__(self, folder_path: str, debug=False, key_path="keys/streetview.txt"):
        # Read API key 
        self.api_key = open(key_path, "r").read()

        # Set debug mode
        self.debug = debug

        # Store folder path and create it if it doesn't exist
        self.folder_path = folder_path
        if not os.path.exists(self.folder_path):
            os.makedirs(self.folder_path)
        
        # Create log for this session, start clock
        self.log = []
    
    def capture_POI(self, poi:POI, fov = 85, points:pd.DataFrame = None,
     heading:float=None, stitch_count=0):
        """
        Main method for capturing photos of a POI. 
        Args:
            poi: The POI to pull pictures of 
            fov: The field of view for all images 
            points: A dataframe of points generated by the multipoint tool 
            heading: The angle that the picture will be taken at, in degrees. Leave as None to automatically estimate. 
            stitch_count: The number of images that will be captured and stitched together
        """
        # Check and update FOV 
        if 120 < fov < 10: 
            print("FOV must be between 10 and 120 degrees") 
            return
        poi.fov = fov

        # Handle multi point pulling
        if points: 
            points.apply(lambda row: 
            self.pull_pic(poi, Pic(heading=row["heading"], number=row.name, stitch_count=stitch_count)), 
            axis=1)
        
        else:
            # Estimate heading if none is provided 
            if heading == None:
                heading = self.estimate_heading(poi)
            
            # Pull pic 
            pic = Pic(heading, stitch_count=stitch_count)
            self.pull_pic(pic)
        
        # Write this POI's entry into the log 
        self.log.append(poi.get_entry())

    def _capture_pic(self, poi: POI, pic: Pic):
        # Pull each images
        if pic.stitch_count > 1:
            # Object to store the images in (as arrays) before stitching 
            imgs = []
            start_heading = pic.heading - ((pic.stitch_count-1)/2 * poi.fov)

            for i in range(pic.stitch_count):
                # Calculate heading for this image
                heading = start_heading + i * poi.fov

                # Pull this image, check for errors, add to list
                img = self._pull_image(poi, heading)
                if not img: return 
                imgs.append(img)
            
            # Stitch images
            final_img = self.stitch_images(imgs)
        else:
            # Pull image, check if nothing is returned (error)
            img = self._pull_image(poi, pic.heading)
            if not img: return 

            # Open as PIL image
            final_img = Image.open(io.BytesIO(img))
        
        # Add either coordinate location or pano ID to path depending on what's in the POI
        if poi.pano_id:
            image_path = self.folder_path + "/" + f"{poi.pano_id}"+".jpg"
        else: 
            image_path = self.folder_path + "/" + f"{poi.coords.to_string()}"+".jpg"

        # Write this image segment into the temp folder
        final_img.save(image_path)

    def _pull_image(self, poi: POI, heading):
        # Parameters for API request
        pic_params = {'key': self.api_key,
                        'size': f"{self.pic_len}x{self.pic_height}",
                        'fov': poi.fov,
                        'heading': heading,
                        'return_error_code': True,
                        'outdoor': True}
        
        # Add location or coordinates
        if poi.pano_id:
            pic_params['pano'] = poi.pano_id
        else:
            pic_params['location'] = poi.coords.to_string()

        # Pull response 
        response = self.pull_response(
            params = pic_params,
            context = "pulling image",
            coords = poi.coords.to_string(),
            base = 'https://maps.googleapis.com/maps/api/streetview?')
        
        # Check for errors 
        if type(response) == Error: 
            poi.errors.append(response)
            return

        # Close response, return content 
        content = response.content
        response.close()
        return content

    def improve_coords(self, poi: POI):
        """
        Pull Google's coordinates for a POI in the event that the provided coordinates suck
        """
        # Build params
        params = {
            'location': poi.coords.to_string(),
            'keyword':poi.key_word,
            'key': self.api_key,
            'rankby':'distance',
            'maxResultCount': 1
        }
        
        # Pull and check response
        response = self.pull_response(
            params,
            'https://maps.googleapis.com/maps/api/place/nearbysearch/json',
            "pulling nearby search results")
        if type(response) == Error:
            poi.errors.append(response)
            return
        
        # Get results from the response
        results = response.json().get('results', [])

        # Take the nearest result and use its coordinates
        if results:
            nearest = results[0]
            location = nearest['geometry']['location']
            updated_coord = Coord(location['lat'], location['lng'])
            poi.coords = updated_coord

        # Handle no results 
        else: 
            poi.error.append(Error("pulling nearby search results", f"no nearby {poi.key_word} found"))
            if self.debug: print(f"No nearby {poi.key_word} found for {poi.coords.to_string()}")

    
    def pull_pano_info(self, poi: POI):
        """
        Extract coordiantes from a pano's metadata, used to determine heading
        """
        # Params for request
        params = {
            'location': poi.coords.to_string(),
            'key': self.api_key
        }

        # Send a request, except faulty responses
        response = self.pull_response(
            params=params,
            coords=poi.coords.to_string(),
            context="pulling metadata",
            base='https://maps.googleapis.com/maps/api/streetview/metadata?')
        
        # Fetch the coordinates from the json response and store them in the POI
        pano_location = response.json().get("location")
        poi.pano_coords = Coord(pano_location["lat"], pano_location["lng"])
        poi.pano_id = response.json().get("pano_id")
    
    def estimate_heading(self, poi: POI):
        """
        Use pano's coords to determine the necessary camera FOV.
        """
        # Get the coordinates of the pano Google pics for this POI
        self.pull_pano_info(poi)

        # Convert latitude to radians, get distance between lon in radians.  
        diff_lon = math.radians(poi.coords.lon - poi.pano_coords.lon)
        lat1 = math.radians(poi.pano_coords.lat)
        lat2 = math.radians(poi.coords.lat)

        # Determine degree
        x = math.sin(diff_lon) * math.cos(lat2)
        y = math.cos(lat1) * math.sin(lat2) - math.sin(lat1) * math.cos(lat2) * math.cos(diff_lon)
    
        bearing = math.atan2(x, y)
        
        # Convert radians to degrees and then compass bearing
        bearing = math.degrees(bearing)
        compass_bearing = (bearing + 360) % 360
        return compass_bearing

    def pull_pano(self, poi: POI, num_pics=8):
        """
        Pulls num_pics many images of a POI and stitches them together into a panorama. 

        Args:
            poi: the POI that will be captured. 
            num_pics: how many pics will be captured and stitched into the pano.
        """
        poi.fov = 360/num_pics
        imgs = []

        # Capture 'num_pics' many photos
        for degree in range(0, 360, int(360/num_pics)):
            # Save image into temp folder, get its path
            poi.heading = degree
            imgs.append(self._pull_image(poi))
        
        # Stitch all the images of this bus stop together
        pano = self.stitch_images(imgs)

        # Add either coordinate location or pano ID depending on what's in the POI
        if poi.pano_id:
            image_path = self.folder_path + "/" + f"{poi.pano_id}"+".jpg"
        else: 
            image_path = self.folder_path + "/" + f"{poi.coords.to_string()}"+".jpg"

        # Write this image segment into the temp folder
        pano.save(image_path)

    def stitch_images(self, imgs):
        # Convert to PIL images
        pil_imgs = [Image.open(io.BytesIO(img_bytes)) for img_bytes in imgs]

        # Create a blank image
        stitched = Image.new('RGB', (self.pic_len*len(imgs), self.pic_height))

        # Paste each of the images onto the blank one
        x_offset = 0
        for img in pil_imgs:
            stitched.paste(img, (x_offset, 0))
            x_offset += img.width
        return stitched
    
    def write_log(self):
        """
            Writes a CSV file with the coordinates, FOV, etc. of each POI.
            Use at the END of a session, IE when you're finished pulling images.
        """
        log_df = pd.DataFrame(self.log)
        log_path = self.folder_path + "/log.csv"
        log_df.to_csv(log_path)
        
    def pull_response(self, params, context, base, coords):
        # Print a sumamry of the request if debugging 
        if self.debug: print(f"{context} for {coords}")

        # Issue request, except timeout
        try:
            response = requests.get(base, params=params, timeout=10)
        except requests.exceptions.Timeout:
            if self.debug: print("Request timed out!")
            return Error(context, "request timed out!")

        # Check if the request was successful
        if response.status_code == 200:
            return response
        else:
            response.close()
            return Error(context, f"({response.status_code}): {response.text}")

